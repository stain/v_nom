/* ***** BEGIN LICENSE BLOCK *****
* Version: CDDL 1.0/LGPL 2.1
*
* The contents of this file are subject to the COMMON DEVELOPMENT AND
* DISTRIBUTION LICENSE (CDDL) Version 1.0 (the "License"); you may not use
* this file except in compliance with the License. You may obtain a copy of
* the License at http://www.sun.com/cddl/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
* for the specific language governing rights and limitations under the
* License.
*
* The Original Code is "NOM" Netlabs Object Model
*
* The Initial Developer of the Original Code is
* netlabs.org: Chris Wohlgemuth <cinc-ml@netlabs.org>.
* Portions created by the Initial Developer are Copyright (C) 2007
* the Initial Developer. All Rights Reserved.
*
* Contributor(s):
*
* Alternatively, the contents of this file may be used under the terms of
* the GNU Lesser General Public License Version 2.1 (the "LGPL"), in which
* case the provisions of the LGPL are applicable instead of those above. If
* you wish to allow use of your version of this file only under the terms of
* the LGPL, and not to allow others to use your version of this file under
* the terms of the CDDL, indicate your decision by deleting the provisions
* above and replace them with the notice and other provisions required by the
* LGPL. If you do not delete the provisions above, a recipient may use your
* version of this file under the terms of any one of the CDDL or the LGPL.
*
* ***** END LICENSE BLOCK ***** */
#include <os2.h>
#include <stdlib.h>
#include <string.h>

#include <glib.h> 
#include <glib/gprintf.h> 

#define INCL_FILE
#include "parser.h"

extern GScanner *gScanner;

static void emitIHFileHeader(PPARSEINFO pLocalPI, PINTERFACE pif)
{
  gchar *chrTemp;
  FILE* fh=pLocalPI->outFile;

  fprintf(fh, "/*\n * This file was generated by the NOM IDL compiler for Voyager - DO NOT EDIT!\n");
  fprintf(fh, " *\n *\n * And remember, phase 3 is near...\n */\n");
  fprintf(fh, "/*\n * %s\n */\n", pif->chrSourceFileName);

  /* Protective #ifndef for whole file */
  fprintf(fh, "#ifndef %s_IH\n#define %s_IH\n\n", pif->chrName, pif->chrName);

  /* The *.h of this class contains some declarations we need */
  chrTemp=strlwr(g_strdup(pif->chrName));
  fprintf(fh, "#include \"%s.h\"\n\n", chrTemp);
  g_free(chrTemp);
}


static void emitInstanceVariables(PPARSEINFO pLocalPI, PINTERFACE pif)
{
  int a;
  FILE* fh=pLocalPI->outFile;
  GPtrArray *pArray=pif->pInstanceVarArray;;

  fprintf(fh, "/*\n * Instance variables for %s\n */\n", pif->chrName);
  fprintf(fh, "typedef struct {\n");

  for(a=0;a<pArray->len;a++)
    {
      int b;
      PMETHODPARAM piv=(PMETHODPARAM)g_ptr_array_index(pArray, a);

            fprintf(fh, "    %s", piv->chrType);
            for(b=0;b<piv->uiStar;b++)
              fprintf(fh, "*");
            fprintf(fh, "  %s;\n", piv->chrName);
    }
  fprintf(fh, "}%sData;\n\n", pif->chrName);
}

static void emitGetDataMacros(PPARSEINFO pLocalPI, PINTERFACE pif)
{
  FILE* fh=pLocalPI->outFile;
  GPtrArray *pArray=pif->pInstanceVarArray;;
  int a;

  fprintf(fh, "/*\n * Get data macros for %s\n */\n", pif->chrName);
  fprintf(fh, "typedef %sData* NOMLINK nomTP_%s_DataThunk(void*);\n",
          pif->chrName , pif->chrName);
  fprintf(fh, "typedef nomTP_%s_DataThunk *nomTD_%s_DataThunk;\n",
          pif->chrName , pif->chrName);

  fprintf(fh, "#define %sGetData(nomSelf) \\\n", pif->chrName);
  fprintf(fh, "    (((nomTD_%s_DataThunk)(%sCClassData.instanceDataToken))(nomSelf))\n",
          pif->chrName , pif->chrName);

  for(a=0;a<pArray->len;a++)
    {
      PMETHODPARAM piv=(PMETHODPARAM)g_ptr_array_index(pArray, a);
      
      fprintf(fh, "#define  _%s (nomThis->%s);\n", piv->chrName, piv->chrName);
    }
  fprintf(fh, "\n");
}


static void emitIHClassDataStructs(PPARSEINFO pLocalPI, PINTERFACE pif)
{
  FILE* fh=pLocalPI->outFile;

  fprintf(fh, "#ifdef NOM_%s_IMPLEMENTATION_FILE\n\n", pif->chrName);

  fprintf(fh, "/*** Class data structures ***/\n");
  fprintf(fh, "struct %sClassDataStructure %sClassData = {0};\n", pif->chrName, pif->chrName );
  fprintf(fh, "static struct %sCClassDataStructure %sCClassData = {0};\n\n",
          pif->chrName, pif->chrName);
}

#if 0
/* Function to check if an object is valid before calling a method on it */
#ifdef NOM_NO_PARAM_CHECK /* Disabled by now because not working */
NOMEXTERN gboolean NOMLINK objectCheckFunc_WPRootFolder(WPRootFolder *nomSelf, gchar* chrMethodName)
{
if(!nomIsObj(nomSelf) || !_nomIsANoClsCheck(nomSelf , WPRootFolderClassData.classObject, NULLHANDLE))
  {
  nomPrintObjectPointerError(nomSelf, "WPRootFolder", chrMethodName);
  g_message("Note that NULL is returned for the call (if the method returns a value). This may not be correct. Use the NOMPARMCHECK() macro to specify default return values for methods.");
  return FALSE;
  }
  return TRUE;
}
#endif
#endif

static void emitOverridenMethods(PPARSEINFO pLocalPI, PINTERFACE pif)
{
  FILE* fh=pLocalPI->outFile;
  GPtrArray *pArray;
  int a;

  pArray=pif->pOverrideArray;

  for(a=0;a<pArray->len;a++)
    {
      int b;
      POVERMETHOD pom=(POVERMETHOD)g_ptr_array_index(pArray, a);
      /* Method information */
      PMETHOD pm=findMethodInfoFromMethodName(pif, pom->chrName);
      /* Pointer to interface which introduced the method */
      PINTERFACE pifIntroduced=findInterfaceFromMethodName(pif, pom->chrName);

      fprintf(fh, "/*\n * Overriden method: %s \n */\n",  pom->chrName);
      fprintf(fh, "#ifndef _decl_impl_%s_%s_\n", pif->chrName, pom->chrName);
      fprintf(fh, "#define _decl_impl_%s_%s_\n", pif->chrName,  pom->chrName);

      if(!pm || !pifIntroduced)
        {
          g_message("Can't get information about method \"%s\" from parent classes while overriding.", pom->chrName);
          exit(1);
        }

      fprintf(fh, "NOM_Scope %s", pm->mpReturn.chrType);
      for(b=0;b<pm->mpReturn.uiStar;b++)
        fprintf(fh, "*");

      fprintf(fh, " NOMLINK impl_%s_%s(%s* nomSelf,\n", pif->chrName, pom->chrName, pif->chrName);
      /* Do parameters */
      emitMethodParams(pLocalPI, pif, pm->pParamArray);
      fprintf(fh, " CORBA_Environment *ev);\n");
      fprintf(fh, "static char* nomIdString_%s_%s = \"%s:%s\";\n",
              pif->chrName, pom->chrName, pifIntroduced->chrName, pom->chrName);
      fprintf(fh, "static nomMethodProc* %s_%s_parent_resolved;\n",
              pif->chrName, pom->chrName);
      fprintf(fh, "#define %s_%s_parent(nomSelf,",
              pif->chrName, pom->chrName);
      emitMethodParamsNoTypes(pLocalPI, pif, pm->pParamArray);
      fprintf(fh, " ev) \\\n");
      fprintf(fh, "        (((nomTD_%s_%s) \\\n", pif->chrName, pom->chrName);

      fprintf(fh, "        %s_%s_parent_resolved)((%s*)nomSelf,",
              pif->chrName, pom->chrName, pifIntroduced->chrName);
      emitMethodParamsNoTypes(pLocalPI, pif, pm->pParamArray);
      fprintf(fh, " ev))\n");
      fprintf(fh, "#endif /* _decl_impl_%s_%s_ */\n\n", pif->chrName, pom->chrName);
    }
};

static void emitOverridenMethodTable(PPARSEINFO pLocalPI, PINTERFACE pif)
{
  FILE* fh=pLocalPI->outFile;
  GPtrArray *pArray;
  int a;

  fprintf(fh, "/*** Overriden method table ***/\n");
  fprintf(fh, "static nomOverridenMethodDesc nomOverridenMethodsWPRootFolder[] = {\n");

  for(a=0;a<pArray->len;a++)
    {
      POVERMETHOD pom=(POVERMETHOD)g_ptr_array_index(pArray, a);
      /* Method information */
      PMETHOD pm=findMethodInfoFromMethodName(pif, pom->chrName);

      if(!pm)
        {
          g_message("Can't get information about method \"%s\" from parent classes while overriding.", pom->chrName);
          exit(1);
        }

      fprintf(fh, "  {\n");
      fprintf(fh, "    &nomIdString_%s_%s,\n", pif->chrName,  pom->chrName);
      fprintf(fh, "    (nomMethodProc*) impl_%s_%s,\n", pif->chrName,  pom->chrName);
      fprintf(fh, "    &%s_%s_parent_resolved\n", pif->chrName,  pom->chrName);
      fprintf(fh, "  },\n");
    }
    fprintf(fh, "};\n\n");

}

static void emitIHFileFooter(PPARSEINFO pLocalPI, PINTERFACE pif)
{
  FILE* fh=pLocalPI->outFile;

  fprintf(fh, "\n#endif /* NOM_%s_IMPLEMENTATION_FILE */\n", pif->chrName);
  fprintf(fh, "#endif/* %s_IH */\n", pif->chrName);
}

void emitIHFile(GPtrArray* pInterfaceArray)
{
  int a;
  PPARSEINFO pLocalPI=(PPARSEINFO)gScanner->user_data;

  for(a=0;a<pInterfaceArray->len;a++)
    {
      PINTERFACE pif=g_ptr_array_index(pLocalPI->pInterfaceArray, a); 
      if(!strcmp(pif->chrSourceFileName, pLocalPI->chrRootSourceFile))
        {
          gchar*  chrTemp;

          printInterface(pif);
          
          chrTemp=g_strconcat(pif->chrFileStem, ".ih", NULL);
          if((pLocalPI->outFile=openOutfile(gScanner, chrTemp))!=NULLHANDLE)
            {
              emitIHFileHeader(pLocalPI, pif);
              emitInstanceVariables(pLocalPI, pif);
              emitGetDataMacros(pLocalPI, pif);
              emitIHClassDataStructs(pLocalPI, pif);
              emitOverridenMethods(pLocalPI, pif);
              emitOverridenMethodTable(pLocalPI, pif);

              emitIHFileFooter(pLocalPI, pif);
            }
          g_free(chrTemp);
        }
    }
}


